В настоящий момент единственным методом авторизации REST запроса является механизм HMAC (hash based message authentication)

h3. Авторизация с помощью HMAC

Что такое HMAC Можно прочитать тут: http://restcookbook.com/Basics/loggingin/

**Важно! Информация размещенная по данной ссылке является лишь иллюстрацией различных техник авторизации HTTP запросов. Алгоритмы, форматы данных и пр. элементы API представленные в статье на restcookbook.com могут отличатся от требований предоставляемый API системы Hive.**

Примеры реализации на разных платформах:

* [[Пример на Java 1.8|HMAC-авторизация#Пример-на-java-18]]
* [[Пример на Python|HMAC-авторизация#Пример-на-python]]

Основной алгоритм, принятый для вычисления Message Digest'а - *SHA256*

Для авторизации на сервере нужно будет передать кучку данных в Header'е HTTP запроса:
* заголовок *Date* в формате *RFC-1123*. Примеры правильных представлений дат:
```
Tue, 3 Jun 2008 11:05:30 GMT
Mon, 23 May 2016 16:39:39 +0600
```
* заголовок *Authentication* Следующего содержания: ```hmac ${identity}:${nonce}:${digest}```, где:
** *identity* - Идентификатор пользователя, от имени которого делается запрос {login, номер телефона, что-то еще}. С помощью этого идентификатора система должна будет обнаружить ключ соответствующий данному пользователю.
** *nonce* - некоторое целое число, уникально идентифицирующее запрос на некотором дискретном временном промежутке (например 10 мин). Каждый новый запрос должен сопровождаться новым значением *nonce*
** *digest* - Подпись сообщения, вычисляемая как ```base64encode(hmac("sha256", {secret}, {Request.method} + {Request.uri} + {Request.header.Date} + {nonce}))```. Тут *secret* – секретный ключ, расшаренный между клиентом и сервисом. Для *POST* запроса вида *“http://localhost:8080/api/client/mobile/1.0/orders”* вычислить digest можно следующим образом: ```base64encode(hmac("sha256", {secret}, "POST" + "/api/client/mobile/1.0/orders" + "Mon, 23 May 2016 16:39:39 +0600" + "114696735"))```. _TODO: написать правильное понятное описание_

Значения *identity* и *secret* получаются в ходе [[регистрации|Подтверждение-клиента#confirmed]].

Если авторизация неудачна, вернется ответ с кодом 401.

----

h3. Пример значений заголовков

<pre><code>Date:Mon, 23 May 2016 16:39:39 +0600
Authentication:hmac system:114696735:7pi1GNhLzUSp5JVKFgkB0VZykud-fT3wJOVqiwDnKOE=
</code></pre>

----

h3. Пример на Java 1.8

В данном разделе приведен пример формирования заголовков *Date* и *Authentication* с использованием языка программирования Java (>=1.8). Приведенный фрагмент кода всего-лишь пример и не предназначен для использования в production решениях. Вы можете свободно использовать данный пример на свой страх и риск :)

```java

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.Charset;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;


/**
 * Naive implementation of HMAC Signer.
 * Beware!: It is not thread safe!!!
 */
public class NaiveHmacSigner {

    private final Mac mac;
    private final String identity;
    private final SecureRandom rnd = new SecureRandom();


    public NaiveHmacSigner(String identity, Mac mac) {
        this.mac = mac;
        this.identity = identity;
    }

    private static final Charset UTF8 = Charset.forName("UTF-8");
    private static final DateTimeFormatter DATEFORMAT =
            DateTimeFormatter.RFC_1123_DATE_TIME;
    

    public Map<String, String> newSignature(String method, String uri) {

        final String dateHeaderValue = OffsetDateTime.now().format(DATEFORMAT);
        final String nonce = "" + Math.abs(this.rnd.nextInt());
        final String signData = method + uri + dateHeaderValue + nonce;

        this.mac.reset();
        final byte[] signBytes = this.mac.doFinal(signData.getBytes(UTF8));
        final String signBase64 = Base64.getEncoder().encodeToString(signBytes);
        final String authHeaderValue =
                String.format("hmac %s:%s:%s", this.identity, nonce, signBase64);

        final Map<String, String> result = new HashMap<>();
        result.put("Date", dateHeaderValue);
        result.put("Authentication", authHeaderValue);
        return result;
    }


    private static final  String HMAC_SHA256_KEYSPEC = "HmacSHA256";


    public static NaiveHmacSigner newSigner(String identity, byte[] secret)
            throws NoSuchAlgorithmException, InvalidKeyException {

        final Mac mac = Mac.getInstance(HMAC_SHA256_KEYSPEC);
        final SecretKeySpec spec = new SecretKeySpec(secret, HMAC_SHA256_KEYSPEC);
        mac.init(spec);
        return new NaiveHmacSigner(identity, mac);
    }
}

```

h3. Пример на Python

В данном разделе приведен пример формирования заголовков *Date* и *Authentication* с использованием языка программирования Python. 

```python
from datetime import datetime
import random
import hmac
import hashlib
import base64

MAXINT = 2**32
WEEKDAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]


def now_rfc_1123():

    date = datetime.utcnow()
    weekday = WEEKDAYS[date.weekday()]
    month = MONTHS[date.month - 1]
    return "%s, %02d %s %04d %02d:%02d:%02d GMT" % \
           (weekday, date.day, month, date.year, 
            date.hour, date.minute, date.second)


class NaiveHmacSigner:

    def __init__(self, permanent_id, key):

        self.__id = str(permanent_id)
        self.__key = base64.standard_b64decode(key)

    def sign(self, *args):

        line = ''
        for entry in args:
            line = line + entry

        signature_bytes = \
            hmac.new(
                key=self.__key, 
                msg=line.encode('utf-8'), 
                digestmod=hashlib.sha256).digest()
        return base64.standard_b64encode(signature_bytes).decode()

    def new_signature(self, method, uri):

        rand_value = str(random.randint(0, MAXINT))
        date_value = now_rfc_1123()
        auth_value = "hmac %s:%s:%s" % \
                     (self.__id, rand_value, 
                      self.sign(method.upper(), uri, date_value, rand_value))

        return {
            u'Date': date_value,
            u'Authentication': auth_value
        }


c = NaiveHmacSigner(12312313, 'beKXDqRvkrbz+aQpEgn41SSh+9qtLAsb0r2cbcQ24cM=')
print(c.new_signature('GET', '/api/client/mobile/1.0/history'))

```

h3. Пример на PHP

```php
<?php

class NaiveHmacSigner {

  private $identity;

  private $secret;

  public function __construct($id, $key) {
    $this->identity = $id;
    $this->secret = base64_decode($key);
  }

  private function hmac($algorithm, $secret, $data) {
    return hex2bin(hash_hmac($algorithm, $data, $secret));
  }

  public function newSignature($requestMethod, $requestPath) {

    $nonce = time();
    $date = date(DATE_RFC1123);

    $data = $requestMethod . $requestPath . $date . $nonce;

    $digest = base64_encode($this->hmac("sha256", $this->secret, $data));

    return array(
      "Authentication" => "hmac " . $this->identity . ":" . $nonce . ":" . $digest,
      "Date" => $date
    );
  }
}

$signer = new NaiveHmacSigner(12312313, "beKXDqRvkrbz+aQpEgn41SSh+9qtLAsb0r2cbcQ24cM=");
$signature = $signer->newSignature("GET", "/api/client/mobile/1.0/history");

print_r($signature);

?>
```