В настоящий момент единственным методом авторизации REST запроса является механихм HMAC (hash based message authentication)

h3. Авторизация с помощью HMAC

Что такое HMAC Можно прочитать тут: http://restcookbook.com/Basics/loggingin/


**Важно! Информация размещенная по данной ссылке является лишь иллюстрацией различных техник авторизации HTTP запросов. Алгоритмы, форматы данных и пр. элементы API представленные в статье на restcookbook.com могут отличатся от требований предоставляемый API системы Hive.**

Основной алогритм, принятый для вычисления Message Digest'а - *SHA256*

Для авторизации на сервере нужно будет передать кучку данных в Header'е HTTP запроса:
* заголовок *Date* в формате *RFC-1123*. Примеры правильных представлений дат:
<pre><code>Tue, 3 Jun 2008 11:05:30 GMT
Mon, 23 May 2016 16:39:39 +0600
</code></pre>
* заголовок *Authentication* Следующего содержания: @hmac ${identity}:${nonce}:${digest}@, где:
** *identity* - Идентификатор пользователя, от имени которого делается запрос {login, номер телефона, что-то еще}. С помощью этого идентификатора система должна будет обнаружить ключ соответствующий данному пользователю.
** *nonce* - некоторое целое число, уникально идентифицирующее запрос на некотором дискретном временном промежутке (например 10 мин). Каждый новый запрос должен сопровождаться новым значением *nonce*
** *digest* - Подпись сообщения. Подпись - это строка содержащая закодированный с помощью алгоритма Base64 массив байт, который получается в результате применения SHA функции к строке подписи, которая в свою очередь также является массивом байт. Строка подписи получается в результате конкатенации 2-х массивов байт, вот так: 
``` 
signature_line_bytes = ${secret} +
                 utf8bytes(${Request.method} + ${Request.uri} + ${Request.header.Date} + ${nonce});
```
Тут:
*** *secret* секретный ключ полученный при регистрации пользователя (массив байт)
*** *Request.method* - значение HTTP Method'а (GET, POST...) (текст)
*** *Request.uri* - URI запроса (текст)
*** *Request.header.Date* - Зачение HTTP заголовка *Date* (текст)
*** *nonce* - Уникальный (на некотором дискретном временном промежутке) ID запроса.
*** Функция *utf8bytes()* - приводит текстовые значения в массив байт в кодировке UTF8;

Теперь можно вычислить значение *digest* следующим образом:
```
digest_bytes = sha256(signature_line_bytes);
digest = base64encodeToString(digest_bytes);
```
 Для *POST* запроса вида *"http://localhost:8080/api/client/mobile/1.0/orders"* вычислить *digest* можно следующим образом: 
```
base64encodeToString(
  sha256({secret} + 
    utf8bytes(
      "POST" + 
      "/api/client/mobile/1.0/orders" + 
      "Mon, 23 May 2016 16:39:39 +0600" + 
      "114696735"
    )
  )
)
```

----

Пример Header'ов необходимых для авторизации посредством HMAC:

<pre><code>Date:Mon, 23 May 2016 16:39:39 +0600
Authentication:hmac system:114696735:7pi1GNhLzUSp5JVKFgkB0VZykud-fT3wJOVqiwDnKOE=
</code></pre>

----

В данном API *identity* и *secret* получаются в ходе [[регистрации|Подтверждение-клиента#confirmed]].

----

h3. Пример на Java 1.8

В данном разделе приведен пример формирования заголовков *Date* и *Authentication* с использованием языка программирования Java (>=1.8). Приведенный фрагмент кода всего-лишь пример и не предназначен для использования в production решениях. Вы можете свободно использовать данный пример на свой страх и риск :)

```java

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.Charset;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;


/**
 * Naive implementation of HMAC Signer.
 * Beware!: It is not thread safe!!!
 */
public class NaiveHmacSigner {

    private final Mac mac;
    private final String identity;
    private final SecureRandom rnd = new SecureRandom();


    public NaiveHmacSigner(String identity, Mac mac) {
        this.mac = mac;
        this.identity = identity;
    }

    private static final Charset UTF8 = Charset.forName("UTF-8");
    private static final DateTimeFormatter DATEFORMAT =
            DateTimeFormatter.RFC_1123_DATE_TIME;
    

    public Map<String, String> newSignature(String method, String uri) {

        final String dateHeaderValue = OffsetDateTime.now().format(DATEFORMAT);
        final String nonce = "" + Math.abs(this.rnd.nextInt());
        final String signData = method + uri + dateHeaderValue + nonce;

        this.mac.reset();
        final byte[] signBytes = this.mac.doFinal(signData.getBytes(UTF8));
        final String signBase64 = Base64.getEncoder().encodeToString(signBytes);
        final String authHeaderValue =
                String.format("hmac %s:%s:%s", this.identity, nonce, signBase64);

        final Map<String, String> result = new HashMap<>();
        result.put("Date", dateHeaderValue);
        result.put("Authentication", authHeaderValue);
        return result;
    }


    private static final  String HMAC_SHA256_KEYSPEC = "HmacSHA256";


    public static NaiveHmacSigner newSigner(String identity, byte[] secret)
            throws NoSuchAlgorithmException, InvalidKeyException {

        final Mac mac = Mac.getInstance(HMAC_SHA256_KEYSPEC);
        final SecretKeySpec spec = new SecretKeySpec(secret, HMAC_SHA256_KEYSPEC);
        mac.init(spec);
        return new NaiveHmacSigner(identity, mac);
    }
}

```